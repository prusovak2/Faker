# Implementation notes

## Random Generator Alg implementation

https://en.wikipedia.org/wiki/Xorshift

https://en.wikipedia.org/wiki/Pseudorandom_number_generator

https://en.wikipedia.org/wiki/Middle-square_method#Middle_Square_Weyl_Sequence_PRNG

https://en.wikipedia.org/wiki/Weyl_sequence

https://en.wikipedia.org/wiki/Mersenne_Twister

http://prng.di.unimi.it/

https://peteroupc.github.io/random.html#Nondeterministic_Sources_and_Seed_Generation

https://github.com/peteroupc/peteroupc.github.io/blob/master/randomtest.md

https://www.pcg-random.org/posts/how-to-test-with-practrand.html

### Other distributions

https://math.stackexchange.com/questions/788814/a-binomial-random-number-generating-algorithm-that-works-when-n-times-p-is

http://www.randomnumbergenerator.com/distribution.asp

https://towardsdatascience.com/6-ways-to-test-for-a-normal-distribution-which-one-to-use-9dcf47d8fa93

https://docs.python.org/3/library/random.html

The art of computer programming. Vol.2. Seminumerical algorithms by Knuth, Donald E (z-lib.org)

#### Ziggurat

https://www.researchgate.net/publication/5142790_The_Ziggurat_Method_for_Generating_Random_Variables

https://en.wikipedia.org/wiki/Ziggurat_algorithm

https://heliosphan.org/zigguratalgorithm/zigguratalgorithm.html

https://github.com/colgreen/Redzen/blob/master/Redzen/Numerics/Distributions/Double/ZigguratGaussian.cs

https://github.com/BartMassey/ziggurat/blob/master/exponential.c



### Source Generators

https://sourcegen.dev/

https://github.com/davidwengier/SourceGeneratorTemplate

https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/

[https://github.com/dotnet/roslyn/blob/master/docs/features/source-generators.cookbook.md](https://l.messenger.com/l.php?u=https%3A%2F%2Fgithub.com%2Fdotnet%2Froslyn%2Fblob%2Fmaster%2Fdocs%2Ffeatures%2Fsource-generators.cookbook.md&h=AT3ACFalO0lCQFWQqqAQYv0LzNG_KZ6SL44pxO1WTdxaG0mVW3YTpWnoq67ZetG9lSnPRDtOD99svhkYABZFyH7_sC9EWpMhK9Zf5hdboAbcv_o7aUv8aQgpXTwarm-IX4tYdRwkIH6ahysIwZhx_w)

[https://github.com/dotnet/roslyn/blob/master/docs/features/source-generators.md](https://l.messenger.com/l.php?u=https%3A%2F%2Fgithub.com%2Fdotnet%2Froslyn%2Fblob%2Fmaster%2Fdocs%2Ffeatures%2Fsource-generators.md&h=AT3ACFalO0lCQFWQqqAQYv0LzNG_KZ6SL44pxO1WTdxaG0mVW3YTpWnoq67ZetG9lSnPRDtOD99svhkYABZFyH7_sC9EWpMhK9Zf5hdboAbcv_o7aUv8aQgpXTwarm-IX4tYdRwkIH6ahysIwZhx_w)

[https://www.youtube.com/watch?v=3YwwdoRg2F4&t=862s](https://l.messenger.com/l.php?u=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3D3YwwdoRg2F4%26t%3D862s&h=AT3ACFalO0lCQFWQqqAQYv0LzNG_KZ6SL44pxO1WTdxaG0mVW3YTpWnoq67ZetG9lSnPRDtOD99svhkYABZFyH7_sC9EWpMhK9Zf5hdboAbcv_o7aUv8aQgpXTwarm-IX4tYdRwkIH6ahysIwZhx_w)

[https://www.youtube.com/watch?v=zHYd9o7-wlw](https://l.messenger.com/l.php?u=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DzHYd9o7-wlw&h=AT3ACFalO0lCQFWQqqAQYv0LzNG_KZ6SL44pxO1WTdxaG0mVW3YTpWnoq67ZetG9lSnPRDtOD99svhkYABZFyH7_sC9EWpMhK9Zf5hdboAbcv_o7aUv8aQgpXTwarm-IX4tYdRwkIH6ahysIwZhx_w)

[https://sergvasiliev.medium.com/introduction-to-roslyn-and-its-use-in-program-development-bce2043fc45d#.2k8fxxg3p](https://l.messenger.com/l.php?u=https%3A%2F%2Fsergvasiliev.medium.com%2Fintroduction-to-roslyn-and-its-use-in-program-development-bce2043fc45d%23.2k8fxxg3p&h=AT3ACFalO0lCQFWQqqAQYv0LzNG_KZ6SL44pxO1WTdxaG0mVW3YTpWnoq67ZetG9lSnPRDtOD99svhkYABZFyH7_sC9EWpMhK9Zf5hdboAbcv_o7aUv8aQgpXTwarm-IX4tYdRwkIH6ahysIwZhx_w)

[https://medium.com/rocket-mortgage-technology-blog/generating-code-in-c-1868ebbe52c5](https://l.messenger.com/l.php?u=https%3A%2F%2Fmedium.com%2Frocket-mortgage-technology-blog%2Fgenerating-code-in-c-1868ebbe52c5&h=AT3ACFalO0lCQFWQqqAQYv0LzNG_KZ6SL44pxO1WTdxaG0mVW3YTpWnoq67ZetG9lSnPRDtOD99svhkYABZFyH7_sC9EWpMhK9Zf5hdboAbcv_o7aUv8aQgpXTwarm-IX4tYdRwkIH6ahysIwZhx_w)

[https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/](https://l.messenger.com/l.php?u=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fintroducing-c-source-generators%2F&h=AT3ACFalO0lCQFWQqqAQYv0LzNG_KZ6SL44pxO1WTdxaG0mVW3YTpWnoq67ZetG9lSnPRDtOD99svhkYABZFyH7_sC9EWpMhK9Zf5hdboAbcv_o7aUv8aQgpXTwarm-IX4tYdRwkIH6ahysIwZhx_w)

[https://devblogs.microsoft.com/dotnet/using-c-source-generators-to-create-an-external-dsl/](https://l.messenger.com/l.php?u=https%3A%2F%2Fdevblogs.microsoft.com%2Fdotnet%2Fusing-c-source-generators-to-create-an-external-dsl%2F&h=AT3ACFalO0lCQFWQqqAQYv0LzNG_KZ6SL44pxO1WTdxaG0mVW3YTpWnoq67ZetG9lSnPRDtOD99svhkYABZFyH7_sC9EWpMhK9Zf5hdboAbcv_o7aUv8aQgpXTwarm-IX4tYdRwkIH6ahysIwZhx_w)

[https://github.com/dotnet/roslyn-sdk/blob/master/samples/CSharp/SourceGenerators/SourceGeneratorSamples/CsvGenerator.cs](https://l.messenger.com/l.php?u=https%3A%2F%2Fgithub.com%2Fdotnet%2Froslyn-sdk%2Fblob%2Fmaster%2Fsamples%2FCSharp%2FSourceGenerators%2FSourceGeneratorSamples%2FCsvGenerator.cs&h=AT3ACFalO0lCQFWQqqAQYv0LzNG_KZ6SL44pxO1WTdxaG0mVW3YTpWnoq67ZetG9lSnPRDtOD99svhkYABZFyH7_sC9EWpMhK9Zf5hdboAbcv_o7aUv8aQgpXTwarm-IX4tYdRwkIH6ahysIwZhx_w)

## IgnoreFaker class

Volat z ctoru `BaseFakeru` metodu, co používá reflexion, aby ososala případné `FakerIgnore` atributy z položek třídy plněné pseudonáhodným obsahem, ctor zpomalí 100x (viz benchmarks). 

**Benchmark, výsledky předtím, než byl implementován `IgnoreFaker`**

``` ini
BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19041.746 (2004/?/20H1)
Intel Core i5-7200U CPU 2.50GHz (Kaby Lake), 1 CPU, 4 logical and 2 physical cores
.NET Core SDK=5.0.101
  [Host]     : .NET Core 3.1.10 (CoreCLR 4.700.20.51601, CoreFX 4.700.20.51901), X64 RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 3.1.10 (CoreCLR 4.700.20.51601, CoreFX 4.700.20.51901), X64 RyuJIT


```

| Method              |        Mean |     Error |    StdDev | Ratio | RatioSD | Rank |  Gen 0 | Gen 1 | Gen 2 | Allocated |
| ------------------- | ----------: | --------: | --------: | ----: | ------: | ---: | -----: | ----: | ----: | --------: |
| WithoutIgnoreNOScan |    253.3 ns |   4.82 ns |   8.31 ns |  0.01 |    0.00 |    1 | 0.4282 |     - |     - |     672 B |
| WithoutIgnoreScan   | 21,394.1 ns | 301.76 ns | 267.51 ns |  0.99 |    0.02 |    2 | 2.9297 |     - |     - |    4617 B |
| WithIgnoreScan      | 21,605.3 ns | 358.42 ns | 335.27 ns |  1.00 |    0.00 |    2 | 2.9297 |     - |     - |    4617 B |


```csharp
//ctor added to BaseFaker to allow previous benchmark to run
public BaseFaker(bool scan)
{
    this.Random = new RandomGenerator();
    if (scan)
    {
        ScanIgnoreAttriutes();
    }
}
```

```csharp
//used benchmark
public class WithIgnore
    {
        public int Int;
        public byte Byte;
        [FakerIgnore]
        public short Short { get; set; } = 73;
        public DateTime DateTime { get; set; }
        [FakerIgnore]
        public double Double = 42.73;
        public Guid Guid;
        [FakerIgnore]
        public string IgnoredString { get; set; } = "IGNORED";
        [FakerIgnore]
        public int IgnoredInt = 42;
    }

    public class WithIgnoreFaker : BaseFaker<WithIgnore>
    {
        public WithIgnoreFaker(bool scan) :base(scan)
        {

        }
    }

    public class WithoutIgnore
    {
        public int Int;
        public byte Byte;
        public short Short { get; set; } = 73;
        public DateTime DateTime { get; set; }
        public double Double = 42.73;
        public Guid Guid;
        public string IgnoredString { get; set; } = "IGNORED";
        public int IgnoredInt = 42;
    }

    public class WithoutIgnoreFaker : BaseFaker<WithIgnore>
    {
        public WithoutIgnoreFaker(bool scan) : base(scan)
        {

        }
    }

    [MemoryDiagnoser]
    [RankColumn]
    [Orderer(SummaryOrderPolicy.FastestToSlowest)]
    public class IgnoreBenchmarks
    {
        [Benchmark(Baseline =true)]
        public void WithIgnoreScan()
        {
            //scanning is carried out, class contains FakerIgnore attributes
            new WithIgnoreFaker(true);
        }

        [Benchmark]
        public void WithoutIgnoreScan()
        {
            //scanning is carried out, class doesn't contain FakerIgnore attributes
            new WithoutIgnoreFaker(true);
        }

        [Benchmark]
        public void WithoutIgnoreNOScan()
        {
            //no scanning carried out
            new WithoutIgnoreFaker(false);
        }
    }
```



`FakerIgnore` atributy jsou používány v uživatelem definovaných třídách, které jsou již implementovány s tím, že budou vyplňovány pseudonáhodným obsahem a tento fakt je jedním z hlavních důvodů jejich existence. Takových tříd ale bude pravděpodobně spíše menšina mezi všemi uživatelem definovanými třídami, pro které bude `Faker` používán. Lze předpokládat, že nejčastěji bude `Faker` nadefinován pro třídu, jejíž primární účel nemá s vyplňováním pseudonáhodným obsahem nic společného a pseudonáhodného obsahu je využito např. pro testování funkčnosti či výkonosti.  Nezdá se mi proto smysluplné kvůli okrajovému případu použití s `FakeIgnore`atributy zpomalit mnohem frekventovanější způsob využití bez těchto atributů. 

"Skenování" uživatelem definované třídy, jestli obsahuje `FakerIgnore` atributy je třeba provádět v ctoru `Fakeru`, od kterého uživatelův specializovaný `Faker` dědí. Kdyby automaticky probíhalo v ctoru `BaseFakeru`, došlo by k popisovanému zpomalení base case na úkor corner case.

Jelikož ale ctor předka je  volán na začátku ctoru potomka, nelze to, jestli má ke skenování dojít, řídit nějakým flagem na `BaseFakeru`, jež by se podobně jako `FillEmptyMembers` flag nastavoval z ctoru uživatelem definovaného potomka `BaseFakeru`, protože k nastavení tohoto flagu by došlo až po provedení těla ctoru `BaseFakeru`, kde by ale už bylo třeba hodnoty flagu využít k rozhodnutí, zda skenovat, či nikoli. 

Situaci by bylo možné vyřešit parametrem ctoru `BaseFakeru` (`bool`, co by určoval, zda skenovat, či nikoli). Pak by ale každý ctor uživatelova specializovaného `Fakeru`, který by měl vytvářet instance `Fakeru`, co respektují `FakerIgnore` atributy,  musel  přijímat `bool` parametr (např. `bool doScanning`) a použít konstrukci `:base(doScanning)`. Tento přístup mi přijde syntakticky neohrabaný a netransparentní. Navíc by tak mohly vznikat instance stejného typu `Fakeru`, z nichž některé by `FakerIgnore` atributy respektovaly a některé nikoli, což je matoucí a nekonzistentní.

Proto jsem se rozhodla naimplementovat `IgnoreFaker <TClass>` typ poděděný od `BaseFaker<TClasss>`. V ctoru `IgnoreFakeru` je volán příslušný ctor `BaseFakeru` a navíc je zde provedeno skenování atributů. `BaseFaker` tedy není sám o sobě skenováním zatížen a usage base case není zbytečně zpomalen. Použití `IgnoreFakeru` je stále stejně jednoduché jako použití `BaseFakeru`. 

Nevýhodou tohoto přístupu oproti skenování atributů přímo v ctoru  `BaseFakeru` je menší transparentnost použití `FakerIgnore` atributů. Uživatel, jež si není vědom existence a účelu `IgnoreFakeru` bude zmaten, že jeho `FakerIgnore` atributy nemají ve `Fakeru` poděděném přímo od `BaseFakeru` žádný účinek.  

**Benchmark , `IgnoreFaker` vs `BaseFaker`**

``` ini
BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19041.746 (2004/?/20H1)
Intel Core i5-7200U CPU 2.50GHz (Kaby Lake), 1 CPU, 4 logical and 2 physical cores
.NET Core SDK=5.0.101
  [Host]     : .NET Core 3.1.10 (CoreCLR 4.700.20.51601, CoreFX 4.700.20.51901), X64 RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 3.1.10 (CoreCLR 4.700.20.51601, CoreFX 4.700.20.51901), X64 RyuJIT


```

| Method                   |        Mean |     Error |    StdDev | Rank |  Gen 0 | Gen 1 | Gen 2 | Allocated |
| ------------------------ | ----------: | --------: | --------: | ---: | -----: | ----: | ----: | --------: |
| WithoutIgnoreBaseFaker   |    251.7 ns |   5.03 ns |  11.36 ns |    1 | 0.4282 |     - |     - |     672 B |
| WithIgnoreBaseFaker      |    252.6 ns |   4.97 ns |  10.37 ns |    1 | 0.4282 |     - |     - |     672 B |
| WithoutIgnoreIgnoreFaker | 21,391.5 ns | 409.87 ns | 739.09 ns |    2 | 2.9297 |     - |     - |    4617 B |
| WithIgnoreIgnoreFaker    | 22,056.8 ns | 428.68 ns | 641.63 ns |    3 | 2.9297 |     - |     - |    4617 B |

```csharp
//used benchmark 
public class WithIgnore
    {
        public int Int;
        public byte Byte;
        [FakerIgnore]
        public short Short { get; set; } = 73;
        public DateTime DateTime { get; set; }
        [FakerIgnore]
        public double Double = 42.73;
        public Guid Guid;
        [FakerIgnore]
        public string IgnoredString { get; set; } = "IGNORED";
        [FakerIgnore]
        public int IgnoredInt = 42;
    }

    public class WithIgnoreBaseFaker : BaseFaker<WithIgnore> { }

    public class WithIgnoreIgnoreFaker : IgnoreFaker<WithIgnore> { }
 

    public class WithoutIgnore
    {
        public int Int;
        public byte Byte;
        public short Short { get; set; } = 73;
        public DateTime DateTime { get; set; }
        public double Double = 42.73;
        public Guid Guid;
        public string IgnoredString { get; set; } = "IGNORED";
        public int IgnoredInt = 42;
    }

    public class WithoutIgnoreBaseFaker : BaseFaker<WithIgnore> { }

    public class WithoutIgnoreIgnoreFaker : IgnoreFaker<WithIgnore> { }

    [MemoryDiagnoser]
    [RankColumn]
    [Orderer(SummaryOrderPolicy.FastestToSlowest)]
    public class IgnoreBenchmarks
    {
        [Benchmark]
        public void WithIgnoreBaseFaker()
        {
            // no scanning is carried out, class contains FakerIgnore attributes
            new WithIgnoreBaseFaker();
        }

        [Benchmark]
        public void WithIgnoreIgnoreFaker()
        {
            //scanning is carried out, class contains FakerIgnore attributes
            new WithIgnoreIgnoreFaker();
        }

        [Benchmark]
        public void WithoutIgnoreBaseFaker()
        {
            // no scanning is carried out, class doesn't contain FakerIgnore attributes
            new WithoutIgnoreBaseFaker();
        }

        [Benchmark]
        public void WithoutIgnoreIgnoreFaker()
        {
            //scanning is carried out, class doesn't contain FakerIgnore attributes
            new WithoutIgnoreIgnoreFaker();
        }
    }
```

#### `IgnoreFaker` replaced by `AutoFaker` and `FillEmptyMembers` flag removed

[14.2.2021]

Dear diary, I've discovered a fatal flaw in mechanisms for filling members of the basic types with no Rule set for them. Each time `.Generate()` (`.Populate()`) was called on the instance of `Faker` with `FillEmptyMembes` flag set to `UnfilledMembers.DefaultrandomFunc`, reflection was used to scan for all public properties and fields on `TClass` and afterwards, `HashSet.ExceptWith` method was used several times to remove the members with `RuleFor` or `InnerFaker` set for them from the original `HashSet` and that way a list of members to be filled with a default random function was obtained. Again and again each time `Generate` or `Populate` method was called on the `Faker`.

And what is more, I didn't even realize that once I'm scanning for all member that are field or property, I can extend the condition so that I can leave out the member decorated with `FakerIgnore` attribute and I therefore don't have carry out the second scanning latter on and moreover introduce difficult solution with new type (`IgnoreFaker`) to create a moment in the code execution when it is the most convenient to do this useless second scanning. I'm such dumbass.

```csharp
//original method scanning for member to be filled defaultly
// called from .Populate method that is called from .Generate method 
/// <summary>
/// returns HashSet of all fields and properties of TClass that does 			not have RuleFor or InnerFaker set in this Faker
/// </summary>
/// <returns></returns>
internal HashSet<MemberInfo> GetSetOfMembersToBeFilledByDefaultRandFunc()
{
    if(MembersToBeFilledDefaultly is null)
    {
        Type type = typeof(TClass);
        MembersToBeFilledDefaultly = type.GetMembers().Where(memberInfo => ((memberInfo is PropertyInfo || memberInfo is FieldInfo) && memberInfo.GetCustomAttributes<FakerIgnoreAttribute>().Count() == 0)).ToHashSet();
    }
    HashSet<MemberInfo> memberInfos = MembersToBeFilledDefaultly;
    HashSet<MemberInfo> HasRulefor = this.Rules.Keys.ToHashSet();
    HashSet<MemberInfo> HasSetFaker = this.InnerFakers.Keys.ToHashSet();
    memberInfos.ExceptWith(HasRulefor);
    memberInfos.ExceptWith(HasSetFaker);
    memberInfos.ExceptWith(this.Ignored);

    return memberInfos;
}
```

**Benchmark - scanning in each .Generate, Populate call**

Results cannot be compared with previous Ignore benchmarks as those measured time it takes to run ctor whereas these measures multiple calls to `.Generate` method. 

``` ini
BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19041.804 (2004/?/20H1)
Intel Core i5-7200U CPU 2.50GHz (Kaby Lake), 1 CPU, 4 logical and 2 physical cores
.NET Core SDK=5.0.102
  [Host]     : .NET Core 5.0.2 (CoreCLR 5.0.220.61120, CoreFX 5.0.220.61120), X64 RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 5.0.2 (CoreCLR 5.0.220.61120, CoreFX 5.0.220.61120), X64 RyuJIT


```

| Method                   |     Mean |    Error |   StdDev | Rank |   Gen 0 | Gen 1 | Gen 2 | Allocated |
| ------------------------ | -------: | -------: | -------: | ---: | ------: | ----: | ----: | --------: |
| ScanningBaseFakerNoATTRs | 33.44 μs | 0.644 μs | 1.301 μs |    1 | 11.8408 |     - |     - |   18.2 KB |
| ScanningBaseFakerATTRs   | 35.15 μs | 0.693 μs | 1.267 μs |    2 |  6.1035 |     - |     - |   9.35 KB |
| RuleForBetweenGenerate   | 36.51 μs | 0.715 μs | 1.307 μs |    3 | 12.3291 |     - |     - |  18.89 KB |

```csharp
/// +- used benchmark
[MemoryDiagnoser]
[RankColumn]
[Orderer(SummaryOrderPolicy.FastestToSlowest)]
public class IgnoreWithoutIgnoreFakerBenchmark
{
    public void BaseWith()
    {
        WithIgnoreBaseFaker faker = new();
        WithIgnore x = faker.Generate();
        x = faker.Generate();
    }
    public void BaseWithout()
    {
        WithoutIgnoreBaseFaker faker = new();
        WithoutIgnore x = faker.Generate();
        x = faker.Generate();
    }
    public void BaseWithRuleFor()
    {
        WithIgnoreBaseFaker faker = new();
        WithIgnore x = faker.Generate();
        faker.RuleFor(a => a.Byte, _ => 42);
        x = faker.Generate();
    }
    public void AutoWith()
    {
        WithIgnoreAutoFaker faker = new();
        WithIgnore x = faker.Generate();
        x = faker.Generate();
    }
    public void AutoWithout()
    {
        WithoutIgnoreAutoFaker faker = new();
        WithoutIgnore x = faker.Generate();
        x = faker.Generate();
    }
    public void AutoWithRuleFor()
    {
        WithIgnoreAutoFaker faker = new();
        WithIgnore x = faker.Generate();
        faker.RuleFor(a => a.Byte, _ => 42);
        x = faker.Generate();
    }
    [Benchmark]
    public void BaseFakerAttributes()
    {
        BaseWith();
    }
    [Benchmark]
    public void BaseFakerNoAttributes()
    {
        BaseWithout();
    }
    [Benchmark]
    public void BaseFakerAttributesRuleFor()
    {
        BaseWithRuleFor();
    }
    [Benchmark]
    public void AutoFakerAttributes()
    {
        AutoWith();
    }
    [Benchmark]
    public void AutoFakerNoAttributes()
    {
        AutoWithout();
    }
    [Benchmark]
    public void AutoFakerAttributesRuleFor()
    {
        AutoWithRuleFor();
    }
}
```

**Similar benchmark with scanning carried out only on the first call to .Populate method and `ExceptWith` called on each such call **

``` ini
BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19041.804 (2004/?/20H1)
Intel Core i5-7200U CPU 2.50GHz (Kaby Lake), 1 CPU, 4 logical and 2 physical cores
.NET Core SDK=5.0.102
  [Host]     : .NET Core 5.0.2 (CoreCLR 5.0.220.61120, CoreFX 5.0.220.61120), X64 RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 5.0.2 (CoreCLR 5.0.220.61120, CoreFX 5.0.220.61120), X64 RyuJIT


```

| Method                   |     Mean |    Error |   StdDev | Rank |   Gen 0 | Gen 1 | Gen 2 | Allocated |
| ------------------------ | -------: | -------: | -------: | ---: | ------: | ----: | ----: | --------: |
| ScanningBaseFakerATTRs   | 21.10 μs | 0.420 μs | 0.561 μs |    1 |  3.9978 |     - |     - |   6.14 KB |
| ScanningBaseFakerNoATTRs | 26.49 μs | 0.522 μs | 0.828 μs |    2 | 10.1318 |     - |     - |  15.53 KB |
| RuleForBetweenGenerate   | 32.14 μs | 0.634 μs | 1.295 μs |    3 | 10.5591 |     - |     - |  16.24 KB |



##### Encountered problems

* It is useless to carry out scanning and store the list of members to be filled defaultly in a Faker  that does not intend to do any default filling (not that that had been happening with original design - multiple scanning was only carried out with appropriately set `FillEmtyMembers` flag). 
* It is nonsense to scan a multiple times as scanning heavily uses reflection and it's therefore time demanding. It would be better instead to scan only once at Fakers creation. 
* Furthermore removing all the members with `Rule` or `InnerFaker` set and member that are ignored from the member list obtained by scanning again and again on each `.Populate` call (even though some of these exact members were removed before (taking into account that `ExpectWith` method is linear at the length of extracted `HashSet`)) is wasteful.  On the other hand, adding to each call to the `RuleFor` or `SetFaker` method on the `BaseFaker` instance `HashSet.Remove` method call to keep the list of members to be filled defaultly up to date seems wasteful as well as only these instances that intend to do default filling will benefit from such list.
* It does not make sense to call .`Ignore` method on the Faker that does not intend to carry out default filling (or is not strict)  as it has no effect. 
##### Introduced changes

* `FillEmptyMembers` flag was removes (as well as `UnfilledMembers` enum). Instead `BaseFaker` instances never do default filling and when user wants to benefit from he is to use the instance of `AutoFaker` that always carries out the default filling - improvement in API - clearer and more straightforward to use, got  rid of strangely named flag.
* Member scanning is carried out in derived fakers ctors (`AutoFaker` and `StrictFaker` ctors). Thou property containing the resulting list and the method to obtain contend of such list lives in `BaseFaker` (as internal protected or something like that) so that both deriver Fakers can inherit the implementation and method therefore does not have to be implemented twice, no instance of `BaseFaker` will ever call the scanning method and the `HashSet` property to store the list of members will consequently remain null in each `BaseFaker` instance not wasting much memory.
* `internal protected virtual _internalPopulate` method was added to both `BaseFaker` and `AutoFaker` (its override) to ensure a different behavior of `Populate` method in `Base` and `Auto` `Faker` (`AutoFakers` version does default filling). `public Populate` method is now only the wrapper around the `_internalPopulate`. I opted for this design in order to prevent user from further overriding the `Populate` method in his derived Fakers. I could make a `public virtual Populate` method `sealed` in `AutoFaker` class but I could not use the `sealed` keyword in `BaseFaker` as I needed to provide the override myself in `AutoFaker`. That is why I went with this a bit clumsy design with internal protected virtual `_internalPopulate`.
* Similar design (internal protected virtual) was introduced to enable to to keep `HashSet.Remove` calls removing members that are just being assigned `Rule` or `InnerFaker` only in `AutoFaker`'s and `StrictFaker`'s implementations of `RuleFor` and `SetFaker` to avoid slowing the `BaseFaker` down with unnecessary managing the empty list of members (not) to be filled by default random function.
* BaseFaker now contains only internal protected implemetation of Ignore method and public wrappers are to be found only in AutoFaker and StrictFaker where they make sense.
* API is more compact and consistent as AutoFaker and StrictFaker are incorporated in much more meaningful way and all methods are distributed to the classes based on whether it makes sense to keep them there.
* Orders of magnitude faster them original fucked up design.

``` ini
BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19041.804 (2004/?/20H1)
Intel Core i5-7200U CPU 2.50GHz (Kaby Lake), 1 CPU, 4 logical and 2 physical cores
.NET Core SDK=5.0.102
  [Host]     : .NET Core 5.0.2 (CoreCLR 5.0.220.61120, CoreFX 5.0.220.61120), X64 RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 5.0.2 (CoreCLR 5.0.220.61120, CoreFX 5.0.220.61120), X64 RyuJIT


```

| Method                     |        Mean |     Error |    StdDev | Rank |  Gen 0 | Gen 1 | Gen 2 | Allocated |
| -------------------------- | ----------: | --------: | --------: | ---: | -----: | ----: | ----: | --------: |
| BaseFakerNoAttributes      |    690.6 ns |   5.86 ns |   5.20 ns |    1 | 0.6371 |     - |     - |    1000 B |
| BaseFakerAttributes        |    710.2 ns |  13.93 ns |  13.03 ns |    2 | 0.6371 |     - |     - |    1000 B |
| BaseFakerAttributesRuleFor |  2,243.2 ns |  40.07 ns |  37.48 ns |    3 | 1.1215 |     - |     - |    1760 B |
| AutoFakerAttributes        | 16,403.1 ns | 312.14 ns | 306.56 ns |    4 | 3.5400 |     - |     - |    5554 B |
| AutoFakerAttributesRuleFor | 19,819.9 ns | 308.68 ns | 288.74 ns |    5 | 3.9368 |     - |     - |    6203 B |
| AutoFakerNoAttributes      | 21,823.6 ns | 427.07 ns | 555.31 ns |    6 | 9.6436 |     - |     - |   15165 B |

##### Scannning was moved to static ctor of Auto or Strict Faker

`HashSet` of members to be filled defaultly is now static member of  `BaseFaker` (therefore it should exists once per specialization of Faker), static ctor of Auto and Strict Fakers first checks whether the `HashSet` is null, if so it initializes it via reflection. If already initialized for this user defined type, no scanning occurs again.  Instance ctor of `Auto` and `Strict` `Faker`  copies the static `HashSet` to per instance copy that can be modified in `Auto` and `Strict` `Faker` instances as necessary. Copying the `HashSet` is still much quicker than reflection based scanning -  as following benchmark shows - AutoFaker related benchmark results improved significantly. I suppose that `BaseFaker` relaed benchmark are slower because of other change (using Expressions to compile setters instead of using .SetValue based on reflection). thought I'm not sure why.   

``` ini
BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19041.804 (2004/?/20H1)
Intel Core i5-7200U CPU 2.50GHz (Kaby Lake), 1 CPU, 4 logical and 2 physical cores
.NET Core SDK=5.0.102
  [Host]     : .NET Core 5.0.2 (CoreCLR 5.0.220.61120, CoreFX 5.0.220.61120), X64 RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 5.0.2 (CoreCLR 5.0.220.61120, CoreFX 5.0.220.61120), X64 RyuJIT


```

| Method                     |        Mean |     Error |    StdDev |      Median | Rank |  Gen 0 | Gen 1 | Gen 2 | Allocated |
| -------------------------- | ----------: | --------: | --------: | ----------: | ---: | -----: | ----: | ----: | --------: |
| BaseFakerNoAttributes      |    843.8 ns |   8.44 ns |   6.59 ns |    845.1 ns |    1 | 0.7906 |     - |     - |   1.21 KB |
| BaseFakerAttributes        |    933.9 ns |  25.13 ns |  73.32 ns |    911.7 ns |    2 | 0.7906 |     - |     - |   1.21 KB |
| BaseFakerAttributesRuleFor |  2,576.3 ns |  45.87 ns |  42.90 ns |  2,566.0 ns |    3 | 1.2741 |     - |     - |   1.95 KB |
| AutoFakerAttributes        |  4,028.8 ns |  79.55 ns |  85.12 ns |  3,987.2 ns |    4 | 1.7700 |     - |     - |   2.71 KB |
| AutoFakerAttributesRuleFor |  7,216.8 ns | 180.40 ns | 523.38 ns |  7,060.4 ns |    5 | 2.1820 |     - |     - |   3.34 KB |
| AutoFakerNoAttributes      | 16,987.2 ns | 308.49 ns | 442.43 ns | 16,851.5 ns |    6 | 8.3618 |     - |     - |  12.81 KB |





### Floating point types boarders problem - default values of parameteres for floating point  random methods

[0,1) default range, when lower specified and greater than 1 and upper not specified, borders gonna get swapped, 1 is gonna become lower boarder and lower boarder specified by user is gonna be treated as upper border. BUG! Solve somehow.

**Possible solutions**

* get rid of swapping boarders in ALL random functions with boarders - to preserve consistency

* add parameterless variants for floating point types - what about default values of parameters for overload with lower and upper param? And how about option to specify just one boarder? (just lower or just upper?)  + necessary to add overloads to ALL  random functions that use floating point random functions in question (Lists, enumerables, nullable variants...)

* change defaults to MIN, MAX value (in ALL methods using floating point random methods) and add paramless functions generating values from [0,1) interval (with corresponding method name) 

* **make boarder params nullable, swap only, when they are not null -  benchmark** whether it's gonna too negatively affect the performance 

**Chosen Solution**

Boarder params made nullable for random functions returning floating point types. Parameters of integral random functions remain non nullable. This is slight inconsistency. I, however, believe it is justified. Making parameters of integral random functions nullable would impaired the performance, especially while generating collections as one need to call random function multiple times (as many times as many members of collection he desires to generate) even a slight change of performance is gonna have measurable impact.  Unlike floating point random functions, nullable parameters do provide integral random function with no significant advantage when it comes to usability of the API - default boarders would not change after making params nullable (nor there is any need to change them). Whereas making params of floating point random functions nullable allows us to provide default interval [0,1) for these functions while still preserving sensible swapping of the boarders (when the boarders are passed incorrectly).

The disadvantage  of this approach is that it causes a slight inconsistency as params are passed differently to floating point and non-floating point random function. User, that makes use of passing nullable params to floating point random functions and would like to similarly treat the integral variants of functions is about to be disappointed.  I don't reckon, however, that usage like that would be frequent and it doesn't seems to be good enough reason to slow down basic use cases. 

**Performance is affected just mildly** - few milliseconds. 
`[0,1)` default interval for floating point types is preserved. When only one of the borders is specified by a user, Min/Max value of particular type is chosen as the unspecified boarder. Probably inconsistent with respect to floating point types themselves - default values of boarder differs when non of them is specified and when one of them is specified. Consistent, however, with the behavior of  all other (non-floating point) random methods  as their defaults are Min/Max values. What is more, when only one of the boarders is specified, it makes much more sense to use Min/Max value as the other boarder then it does to chose 0/1 as default it that case. For instance, when user specifies the upper boarder, sensible behavior seem to be to generate values from interval `[min,boarder)` than `[0, boarder)` or `[boarder,0)` depending on whether `boarder > 0`.


``` ini
BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19041.746 (2004/?/20H1)
Intel Core i5-7200U CPU 2.50GHz (Kaby Lake), 1 CPU, 4 logical and 2 physical cores
.NET Core SDK=5.0.101
  [Host]     : .NET Core 3.1.10 (CoreCLR 4.700.20.51601, CoreFX 4.700.20.51901), X64 RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 3.1.10 (CoreCLR 4.700.20.51601, CoreFX 4.700.20.51901), X64 RyuJIT


```

| Method                   |      Mean |    Error |   StdDev |    Median | Rank | Gen 0 | Gen 1 | Gen 2 | Allocated |
| ------------------------ | --------: | -------: | -------: | --------: | ---: | ----: | ----: | ----: | --------: |
| DoubleParamless          |  13.31 ns | 0.228 ns | 0.190 ns |  13.30 ns |    1 |     - |     - |     - |         - |
| DoubleNullableParamless  |  13.49 ns | 0.232 ns | 0.217 ns |  13.48 ns |    1 |     - |     - |     - |         - |
| DoubleTwoParams          |  16.57 ns | 0.233 ns | 0.195 ns |  16.48 ns |    2 |     - |     - |     - |         - |
| DoubleOneParam           |  17.41 ns | 0.275 ns | 0.257 ns |  17.37 ns |    3 |     - |     - |     - |         - |
| LongOneParam             |  18.84 ns | 0.297 ns | 0.278 ns |  18.84 ns |    4 |     - |     - |     - |         - |
| LongTwoParams            |  19.01 ns | 0.268 ns | 0.250 ns |  19.08 ns |    4 |     - |     - |     - |         - |
| LongNullableTwoParams    |  19.10 ns | 0.343 ns | 0.304 ns |  19.10 ns |    4 |     - |     - |     - |         - |
| LongNullableParamless    |  19.46 ns | 0.291 ns | 0.258 ns |  19.41 ns |    4 |     - |     - |     - |         - |
| IntParamless             |  19.98 ns | 0.397 ns | 0.516 ns |  19.97 ns |    5 |     - |     - |     - |         - |
| LongParamless            |  20.48 ns | 0.451 ns | 1.037 ns |  19.93 ns |    5 |     - |     - |     - |         - |
| DoubleNullableTwoParams  |  20.49 ns | 0.172 ns | 0.153 ns |  20.48 ns |    5 |     - |     - |     - |         - |
| LongNullableOneParam     |  20.88 ns | 0.771 ns | 2.260 ns |  20.29 ns |    5 |     - |     - |     - |         - |
| DoubleNullableOneParam   |  20.93 ns | 0.404 ns | 0.358 ns |  20.99 ns |    5 |     - |     - |     - |         - |
| IntOneParam              |  22.33 ns | 0.477 ns | 0.860 ns |  22.42 ns |    6 |     - |     - |     - |         - |
| IntTwoParams             |  22.66 ns | 0.478 ns | 0.862 ns |  22.83 ns |    6 |     - |     - |     - |         - |
| IntNullableOneParam      |  25.13 ns | 0.291 ns | 0.243 ns |  25.14 ns |    7 |     - |     - |     - |         - |
| IntNullableParamless     |  25.14 ns | 0.461 ns | 0.431 ns |  25.04 ns |    7 |     - |     - |     - |         - |
| IntNullableTwoParams     |  25.15 ns | 0.221 ns | 0.184 ns |  25.15 ns |    7 |     - |     - |     - |         - |
| DecimalParamless         | 114.36 ns | 1.269 ns | 1.125 ns | 114.39 ns |    8 |     - |     - |     - |         - |
| DecimalNullableParamless | 115.65 ns | 2.054 ns | 1.821 ns | 115.64 ns |    8 |     - |     - |     - |         - |
| DecimalOneParam          | 265.58 ns | 3.408 ns | 3.188 ns | 264.75 ns |    9 |     - |     - |     - |         - |
| DecimalTwoParams         | 305.35 ns | 5.888 ns | 5.783 ns | 303.35 ns |   10 |     - |     - |     - |         - |
| DecimalNullableTwoParams | 328.81 ns | 2.720 ns | 2.272 ns | 329.04 ns |   11 |     - |     - |     - |         - |
| DecimalNullableOneParam  | 386.67 ns | 6.270 ns | 5.558 ns | 387.19 ns |   12 |     - |     - |     - |         - |

``` ini
BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19041.746 (2004/?/20H1)
Intel Core i5-7200U CPU 2.50GHz (Kaby Lake), 1 CPU, 4 logical and 2 physical cores
.NET Core SDK=5.0.101
  [Host]     : .NET Core 3.1.10 (CoreCLR 4.700.20.51601, CoreFX 4.700.20.51901), X64 RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 3.1.10 (CoreCLR 4.700.20.51601, CoreFX 4.700.20.51901), X64 RyuJIT


```

| Method                  |      Mean |     Error |    StdDev | Rank | Gen 0 | Gen 1 | Gen 2 | Allocated |
| ----------------------- | --------: | --------: | --------: | ---: | ----: | ----: | ----: | --------: |
| DoubleCompound          |  48.21 ns |  0.526 ns |  0.466 ns |    1 |     - |     - |     - |         - |
| DoubleNullableCompound  |  56.72 ns |  0.614 ns |  0.574 ns |    2 |     - |     - |     - |         - |
| IntCompound             |  58.09 ns |  1.059 ns |  0.938 ns |    3 |     - |     - |     - |         - |
| LongCompound            |  60.14 ns |  0.843 ns |  0.704 ns |    4 |     - |     - |     - |         - |
| LongNullableCompound    |  61.78 ns |  1.257 ns |  1.802 ns |    4 |     - |     - |     - |         - |
| IntNullableCompound     |  77.97 ns |  0.783 ns |  0.733 ns |    5 |     - |     - |     - |         - |
| DecimalCompound         | 702.28 ns |  5.937 ns |  5.553 ns |    6 |     - |     - |     - |         - |
| DecimalNullableCompound | 848.07 ns | 11.807 ns | 11.044 ns |    7 |     - |     - |     - |         - |

### Attempts to use Source Generators with original Faker API unchanged

​	I tried to change implementation underlying `RuleFor` method and memory representation of `Faker` derived objects (user defined Fakers) using `Source Generators` (a new feature that came with `C# 9`).  

I didn't want to change current API of Faker (including the signature of the `RuleFor` method) as I find it convenient, easy to use and more importantly type safe (attempt to a  method as a `RuleFor` a member, whose type is incompatible with a return type of a method will result in compile time error). Original API was well tested by a huge variety of unit tests and has proven to be convenient and straightforward to use (*rephrase this*). Change to the original API that might probably (*think this thought*)  enable incorporation of Source Generators into the project (if that would even be possible, it would definitely require data flow analysis at compile time which is far beyond my current capabilities and time dispositions) would mean too extensive change to the original design of the project that would come too late in the process of project implementation and would be likely to delay a projects completion beyond expected deadline (spring exams).

I meant to move a significant portion of the overhead that comes with storing the information about how the user defined objects with Faker implemented for them should be filled with the pseudorandom content (which random method is to be used for which member of the user defined object) to the compile time.  The idea was to use a new technology of Source Generators and extensive Roslyn API to scan thought a user written code that uses a Fakers in a compile time and based on the obtained information generate a source code of the methods that would carry out the generating and filling the instances of user defined objects in runtime. Generate method overloads and Populate method would be generated for each user defined Faker (instance?) that would contain invocations of the delegates passed to a `RuleFor`  method with the returned values of these invocation assigned to the corresponding members passed to the same `RuleFor` invocation as the first argument. I wanted to replace runtime reflection with compile time source generators.

**Chosen approach**

A `FakerAttribute` was to be added to decorate all the `BaseFaker` derived types considered to be Fakers. This should make scanning for Faker types straightforward and its results unambiguous. 

```csharp
//sorting out the syntax nodes representing declaration of the new Faker derived types in OnSyntaxNode method
else if(syntaxNode is ClassDeclarationSyntax classDeclarationSyntax)
{
    foreach (var atributeList in classDeclarationSyntax.AttributeLists)
    {
        foreach (var attribute in atributeList.Attributes)
        {
            if(attribute.Name.ToString() == "Faker" || attribute.Name.ToString() == "FakerAttribute")
            {
                DeclarationsWithFakerAttr.Add(classDeclarationSyntax);
            }
        }
    }
}
```

  For every `UserFaker` declaration found in previous step it was checked whether it was actually inherited from the `BaseFaker` and if so it was added to `KnownFakerTypes` `HashSet`.

In a similar manner I intended to look up all calls to the `RuleFor` method. As I was unable (just because I'm not familiar with Roslyn API, I pretty sure that thing like that can be done when one knows a bit more what he is doing) state the condition specifying a method name in `OnSyntaxNode` method without restricting the way the method is called (`instance.method()`, `method()`, ....) I sorted out all calls to the methods taking a two arguments of required form of lambda expression and additional conditions where specified in Execute method.

```csharp
//part of OnSyntaxNode -  condition selection invocations of methods with two arguments of required form of lambda function
if (syntaxNode is InvocationExpressionSyntax 
    {
        ArgumentList:
        {
            Arguments:
            {
                Count: 2
            } arguments
        },
        Expression:
        {

        }
    } invocation
   )
{
    if (arguments[0].Expression is LambdaExpressionSyntax memberLambda && arguments[1].Expression is LambdaExpressionSyntax rgLambda)
    {
        if(memberLambda.Body is MemberAccessExpressionSyntax memberAceessSyntax  && 
           rgLambda.Body is InvocationExpressionSyntax RGinvocation && 
           RGinvocation.Expression is MemberAccessExpressionSyntax randFundAccesSyntax)
        {
            SimpleNameSyntax memberName = memberAceessSyntax.Name;
            SimpleNameSyntax randFuncName = randFundAccesSyntax.Name;
            RuleForInvocations.Add(new RuleForPack(invocation, memberName, randFuncName));
        }

    }
}
```

For every found invocation if was checked (latter on in the Execute method) whether the method is actually called `RuleFor` and whether it was invoked on some instance of known `Faker` type (using `KnownFakerTypes` `HashSet`).

```csharp
 foreach (var ruleForPack in RuleForInvocations)
            {
                SemanticModel semanticModel = context.Compilation.GetSemanticModel(ruleForPack.Invocation.SyntaxTree);
                SymbolInfo symbolInfo = semanticModel.GetSymbolInfo(ruleForPack.Invocation);
                IMethodSymbol invokedSymbol = symbolInfo.Symbol as IMethodSymbol;
                string methodName = invokedSymbol.Name;

                if(methodName != "RuleFor")
                {
                    continue;
                }
                //IParameterSymbol firstParam = invokedSymbol.Parameters[0];
                //ITypeSymbol typeSymbol = firstParam.Type;

                IInvocationOperation op = (IInvocationOperation)semanticModel.GetOperation(ruleForPack.Invocation);
                var type = op.Instance.Type;
                if(type is not INamedTypeSymbol namedType)
                {
                    continue;
                }
                if (KnownFakerTypes.Contains(namedType))
                {
                    sourceBuilder.Append($"{indent}Console.WriteLine(\"{type}\");\n");
                    sourceBuilder.Append($"{indent}Console.WriteLine(\"{op.Instance.Kind}\");\n");
                    sourceBuilder.Append($"{indent}Console.WriteLine(\"{methodName}\");\n");
                    sourceBuilder.Append($"{indent}Console.WriteLine(\"{ruleForPack.MemberName}\");\n");
                    sourceBuilder.Append($"{indent}Console.WriteLine(\"{ruleForPack.RandomFunctionName}\");\n");
                    //ADD RuleFor
                }
```

The problem with this designed which made it impossible for me to carry on with Source Generator based implementation as I was unable to bypass it was that current design of the Faker API makes it possible to have a various instances of the same Faker type each of whom may have its  Rules configured differently (instances might have either been created using different `ctors` on user defined Faker type or (not exclusive or) other Rules might have been added for some of the instances latter on outside of `ctor` body -  can I make it impossible to call `RuleFor` from outside of the `ctor` by making `RuleFor` method protected? (respectively from outside of methods defined on `Faker` derived type) and would it even be desirable?). I, however didn't figure out any simple enough way to track something like a notion of instances via Roslyn API in compile time. There is `IInvocationOperation.Instance` that allows me to get a Type on which the method was invoked but I don't reckon that it actually hold some notion of the instance. (Jezek suggested that data flow analysis would be required to achieve desirable effect). 

It is therefore impossible for me at the moment to store a Rules per Faker instance during compile time via Roslyn API (and would that even be desirable as a new method would be generated per `.Generate` call on each instance of user defined `Faker`?) and at the same time storing Rules per user defined Faker type is not sufficient to preserve current API design as well as its behavior.

